<!DOCTYPE html>


<html>

<head>
	<title> Kruskals Algorithm </title>
	<%- include("../partials/header.ejs") %>
	
	<style>
		h1 {
			text-align: center;
			font-weight: 900;
		}
			
		#my_canvas {
			text-align: center;
			border-style: outset;
			border: 5px solid brown;
		}
	</style>
		
	<script type='text/javascript' src='lib/p5.js'></script>
	<script type='text/javascript' src='lib/tools.js'> </script>

</head>

<body>

	<div style='' id='my_canvas'>
	
	</div>

	<script type='text/javascript'>
	
		var screenWidth = screen.availWidth / 1.25;
		var screenHeight = screen.availHeight / 1.5;
		
		var nWidth = 40;
		var nHeight = 40;
		var margin = 100;
		
		let gridDistance = 100;
		
		var alphabet = "ABCEFGHIJKLMNOPQRSTUVWXYZ";
		
		//display
		var oX = 0; //x offset
		var oY = 0; //y offset
		var zoom = 1.0;
		

		
		var currentEdge = -1;
	
		/*
				25(0) --3---  33(1) 
				|    \           \     
				15      6          7
				|	     \    	   \
				13(2) -2- 4[3] -1- 10[4]
			
		*/
		
		var graph = new Graph();
		
		graph.addNode(25); graph.nodes[0].x = 100; graph.nodes[0].y = 100; //n0
		graph.addNode(33); graph.nodes[1].x = 500; graph.nodes[1].y = 100; //n1
		graph.addNode(13); graph.nodes[2].x = 100; graph.nodes[2].y = 500; //n2
		graph.addNode(4); graph.nodes[3].x = 350; graph.nodes[3].y = 500; //n3
		graph.addNode(10); graph.nodes[4].x = 600; graph.nodes[4].y = 500; //n4
		
		graph.addEdge(0,1,3); //e0
		graph.addEdge(0,2,15); //e1
		graph.addEdge(1,4,7); //e2
		graph.addEdge(2,3,2); //e3
		graph.addEdge(3,4,1); //e4
		graph.addEdge(0,3,6); //e5
		
		//graph = generateWeighedGraphGrid(4, 5);
		graph = generateWeightedGraphWeb(10, 10, 10);
		
		function rand(min, max){
			return Math.floor(Math.random() * (max - min)) + min;
		}
		
		function generateWeighedGraphGrid(width, height){ 
			//width and height are integers
			let g = new Graph();
			for(let i = 0; i < height; i++){
				for(let j = 0; j < width; j++){
					g.addNode(alphabet.charAt(i * width + j));
					g.nodes[i * width + j].x = (i * 200) + margin;
					g.nodes[i * width + j].y = (j * 200) + margin;
					if(i > 0){
						g.addEdge(i * width + j, (i - 1) * width + j, rand(1,30));
					}
					if(j > 0){
						g.addEdge(i * width + j, i * width + j - 1, rand(1,30));
					}
				}
			}
			return g;
		}
		
		function generateWeightedGraphWeb(n, w, h){
		
			let g = new Graph();
			var used = [];
			
			for(let i = 0; i < n; i++){
				g.addNode(i);
				let xGrid = 0;
				let yGrid = 0;
				
				do {
					xGrid = rand(0, w);
					yGrid = rand(0, h);
				}while(used.includes(yGrid * w + xGrid));
				used.push(yGrid * w + xGrid);
				
				g.nodes[i].x = margin + xGrid * gridDistance;
				g.nodes[i].y = margin + yGrid * gridDistance;
			}
			makeWebEdges(g, 0);
			
			return g;
		}
		
		
		
		function makeWebEdges(g, i){
		
			let a = g.nodes.map((x) => x);
			quickSortByDistanceFromNode(a, g.nodes[i]);
			for(let j = 1; j < a.length; j++){
				let i2 = g.nodes.indexOf(a[j]);
				if(!edgeExists(g,i,i2)){
					let weight = Math.floor(distanceBetweenNodes(g,i,i2) / 100);
					let edge = new Edge(i, i2, weight);
					let intersect = edgeIntersectsAny(g, edge);
					if(!intersect){
						g.edges.push(edge);
						makeWebEdges(g, i2);
					}
				}
			}
			
		}
		
		function quickSortByDistanceFromNode(a, current){
			quickSort(a, 0, a.length - 1, (ar,n,t) => {
				let d1 = Math.sqrt(Math.pow(ar[n].x - current.x, 2) + Math.pow(ar[n].y - current.y, 2));
				let d2 = Math.sqrt(Math.pow(ar[t].x - current.x, 2) + Math.pow(ar[t].y - current.y, 2));
				return d1 < d2;
			});
		}
		
		function distanceBetweenNodes(g, i, j){
			let n1 = g.nodes[i];
			let n2 = g.nodes[j];
			return Math.sqrt(Math.pow(n1.x - n2.x, 2) + Math.pow(n1.y - n2.y, 2));
		}
		
		function edgeExists(g, i, j){
			for(let x = 0; x < g.edges.length; x++){
				if(g.edges[x].src == i && g.edges[x].dest == j){
					return true;
				}else if(g.edges[x].src == j && g.edges[x].dest == i){
					return true;
				}
			}
			return false;
		}
		function edgeIntersectsAny(g, e){
			for(let x = 0; x < g.edges.length; x++){
				let intersect = edgesIntersect(g, e, g.edges[x]);
				if(intersect == true){
					console.log(e);
					console.log("Intersects...");
					console.log(g.edges[x]);
					
					return true;
				}
			}
			return false;
		}
		
		function edgesIntersect(g, e1, e2){
			let n1 = g.nodes[e1.src];
			let n2 = g.nodes[e1.dest];
			let n3 = g.nodes[e2.src];
			let n4 = g.nodes[e2.dest];
			
			let A1 = n2.y - n1.y;
			let B1 = n1.x - n2.x;
			let C1 = A1 * n1.x + B1 * n1.y;
						
			let A2 = n4.y - n3.y;
			let B2 = n3.x - n4.x;
			let C2 = A2 * n3.x + B2 * n3.y;
			
			let det = A1 * B2 - A2 * B1;
			let x = -1;
			let y = -1;
			
			let slope1 = (n2.y - n1.y) / (n2.x - n1.x);
			let slope2 = (n4.y - n3.y) / (n4.x - n3.x);
			let b1 = (n1.y) - slope1 * n1.x;
			let b2 = (n3.y) - slope2 * n3.x;
			
			if(det == 0){ //lines are parallel
				
				if(n2.x - n1.x == 0){ //one line is vertical, so both lines are vertical b/c they are parallel lines
					if(n1.x == n3.x){ //lines are also colinear
						
						if((Math.min(n3.y, n4.y) < Math.max(n1.y, n2.y) && Math.max(n1.y, n2.y) < Math.max(n3.y, n4.y)) ||
						(Math.min(n1.y, n2.y) < Math.max(n3.y, n4.y) && Math.max(n3.y, n4.y) < Math.max(n1.y, n2.y))){
							return true;
						}
					}
				}else if(b1 == b2){ //lines are parallel, colinear, but not vertical
					if((Math.min(n3.x, n4.x) < Math.max(n1.x, n2.x) && Math.max(n1.x, n2.x) < Math.max(n3.x, n4.x)) ||
					(Math.min(n1.x, n2.x) < Math.max(n3.x, n4.x) && Math.max(n3.x, n4.x) < Math.max(n1.x, n2.x))){
						return true;
					}
				}
				//return false if the lines are parallel but no intersection is found
				return false;
			}else if(edgesHaveCommonNode(e1,e2)){ //not parallel and a common node => no intersection
				return false;
			}else{ //find point of intersection
				x = (B2 * C1 - B1 * C2) / det;
				y = (A1 * C2 - A2 * C1) / det;
 			}
			
			//if the point lies on both segments
			if(pointOnSegment(x,y,n1,n2) && pointOnSegment(x, y, n3,n4)){
				return true;
			}
			return false;
		}
		function edgesHaveCommonNode(e1, e2){
			return (e1.src == e2.src || e1.src == e2.dest || e2.src == e1.dest || e1.dest == e2.dest);
		}
		
		//after finding the point of intersection, this function determines whether the intersection is on both segments
		function pointOnSegment(x,y,n1,n2){
			let minX = Math.min(n1.x, n2.x);
			let maxX = Math.max(n1.x, n2.x);
			let minY = Math.min(n1.y, n2.y);
			let maxY = Math.max(n1.y, n2.y);
			return (minX <= x && x <= maxX && minY <= y && y <= maxY);
		}
		
		
		//finds the representative of a node
		//representative is the node that is the ultimate parent of a group
		function find(parent, n){
			if(parent[n] == n){
				return n;
			}
			return find(parent, parent[n]);
		}
		
		function kruskalsAlgorithmEdgeLoop(graph, parent, result, i){
			if(i < graph.edges.length){
				let e = graph.edges[i];
				let x = find(parent, e.src);
				let y = find(parent, e.dest);
				currentEdge = i;
				if(x != y){
					result.push(e);
					parent[x] = y; //union
				}
				setTimeout(() => {kruskalsAlgorithmEdgeLoop(graph, parent, result, i+1)}, 50);
			}else{
				currentEdge = -1;
			}
		}
		
		function kruskalsAlgorithm(graph, result){
			//find the MST
			//spanning tree connects all of the vertices in a graph without a cycle
			//the minimum spanning tree is the spanning tree with the lowest total weight
			
			//sort the edges from smallest weight to largest weight
			quickSort(graph.edges, 0, graph.edges.length - 1, (a, j, i) => {
				return a[j].weight < a[i].weight;
			});
			var parent = new Array(graph.nodes.length);
			
			for(let i = 0; i < graph.nodes.length; i++){
				parent[i] = i;
			}
			
			
			
			kruskalsAlgorithmEdgeLoop(graph, parent, result, 0);
		}
		
		
		var mst = [];
		kruskalsAlgorithm(graph, mst);
		
		
		
		function setup(){
			var myCanvas = createCanvas(screenWidth, screenHeight);
			myCanvas.parent("my_canvas");
		}
		function draw(){
			background(200);
			textAlign(CENTER, CENTER);
			//display actions
			translate(oX, oY);
			if(mouseIsPressed){
				oX += movedX * 1.5;
				oY += movedY * 1.5;
			}
			scale(zoom);

			
			for(let i = 0; i < graph.edges.length; i++){
				 let e = graph.edges[i]; 
				 strokeWeight(4);
				 if(currentEdge == i){
					stroke(color(0,255,0));
				 }else if(mst.includes(e)){
					stroke(color(255, 0, 0));
					strokeWeight(6);
				 }else{
					stroke(0);
				 }
				 let srcNode = graph.nodes[e.src];
				 let destNode = graph.nodes[e.dest];
				 line(srcNode.x, srcNode.y, destNode.x, destNode.y);
				 
				 let midX = (destNode.x - srcNode.x) / 2 + srcNode.x;
				 let midY = (destNode.y - srcNode.y) / 2 + srcNode.y;
				
				 strokeWeight(1);
				 stroke(0);
				 textSize(8);
				 ellipse(midX, midY, nWidth / 2, nHeight / 2);
				 text(e.weight, midX, midY);
			}
			
			strokeWeight(1);
			textSize(16);

			for(let i = 0; i < graph.nodes.length; i++){
				let n = graph.nodes[i];
				ellipse(n.x, n.y, nWidth, nHeight);
				text(n.value, n.x, n.y);
			}
			
		}
		function mouseWheel(event){
			zoom -= (event.delta / 5000);
		}
		
		
	</script>
</body>

</html> 